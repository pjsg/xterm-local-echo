{"version":3,"file":"index.module.js","sources":["../src/ansi-regex.ts","../node_modules/shell-quote/index.js","../src/HistoryController.ts","../src/unicode.ts","../src/Utils.ts","../src/index.ts","../src/event.ts"],"sourcesContent":["// I don't know why npm install doesn't load it\n// https://github.com/chalk/ansi-regex/\nexport default function ansiRegex({ onlyFirst = false } = {}) {\n  const pattern = [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\n  ].join(\"|\");\n\n  return new RegExp(pattern, onlyFirst ? undefined : \"g\");\n}\n","exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n","/**\n * The history controller provides an ring-buffer\n */\nexport class HistoryController {\n  constructor(private size: number) {}\n\n  public entries: string[] = [];\n  private cursor = 0;\n\n  /**\n   * Push an entry and maintain ring buffer size\n   */\n  push(entry: string): void {\n    // Skip empty entries\n    if (entry.trim() === \"\") return;\n    // Skip duplicate entries\n    const lastEntry = this.entries[this.entries.length - 1];\n    if (entry === lastEntry) {\n      this.cursor = this.entries.length;\n      return;\n    }\n    // Keep track of entries\n    this.entries.push(entry);\n    if (this.entries.length > this.size) {\n      this.entries.shift();\n    }\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Rewind history cursor on the last entry\n   */\n  rewind(): void {\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Returns the previous entry\n   */\n  getPrevious(): string {\n    const idx = Math.max(0, this.cursor - 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n\n  /**\n   * Returns the next entry\n   */\n  getNext(): string {\n    const idx = Math.min(this.entries.length, this.cursor + 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n}\n","// https://github.com/xtermjs/xterm.js/blob/master/src/common/input/UnicodeV6.ts\n\ntype CharWidth = 0 | 1 | 2;\n\nconst BMP_COMBINING = [\n    [0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489],\n    [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2],\n    [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603],\n    [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670],\n    [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED],\n    [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A],\n    [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902],\n    [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D],\n    [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981],\n    [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD],\n    [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C],\n    [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D],\n    [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC],\n    [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD],\n    [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C],\n    [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D],\n    [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0],\n    [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48],\n    [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC],\n    [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD],\n    [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D],\n    [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6],\n    [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E],\n    [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC],\n    [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35],\n    [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E],\n    [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97],\n    [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030],\n    [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039],\n    [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F],\n    [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753],\n    [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD],\n    [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD],\n    [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922],\n    [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B],\n    [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34],\n    [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42],\n    [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF],\n    [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063],\n    [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F],\n    [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B],\n    [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F],\n    [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB]\n];\nconst HIGH_COMBINING = [\n    [0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F],\n    [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169],\n    [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD],\n    [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F],\n    [0xE0100, 0xE01EF]\n];\n\n// BMP lookup table, lazy initialized during first addon loading\nlet table = new Uint8Array(65536);\n\nfunction bisearch(ucs: number, data: number[][]): boolean {\n    let min = 0;\n    let max = data.length - 1;\n    let mid;\n    if (ucs < data[0][0] || ucs > data[max][1]) {\n        return false;\n    }\n    while (max >= min) {\n        mid = (min + max) >> 1;\n        if (ucs > data[mid][1]) {\n            min = mid + 1;\n        } else if (ucs < data[mid][0]) {\n            max = mid - 1;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n// init lookup table once\ntable.fill(1);\ntable[0] = 0;\n// control chars\ntable.fill(0, 1, 32);\ntable.fill(0, 0x7f, 0xa0);\n\n// apply wide char rules first\n// wide chars\ntable.fill(2, 0x1100, 0x1160);\ntable[0x2329] = 2;\ntable[0x232a] = 2;\ntable.fill(2, 0x2e80, 0xa4d0);\ntable[0x303f] = 1;  // wrongly in last line\n\ntable.fill(2, 0xac00, 0xd7a4);\ntable.fill(2, 0xf900, 0xfb00);\ntable.fill(2, 0xfe10, 0xfe1a);\ntable.fill(2, 0xfe30, 0xfe70);\ntable.fill(2, 0xff00, 0xff61);\ntable.fill(2, 0xffe0, 0xffe7);\n\n// apply combining last to ensure we overwrite\n// wrongly wide set chars:\n//    the original algo evals combining first and falls\n//    through to wide check so we simply do here the opposite\n// combining 0\nfor (let r = 0; r < BMP_COMBINING.length; ++r) {\n    table.fill(0, BMP_COMBINING[r][0], BMP_COMBINING[r][1] + 1);\n}\n\nexport function wcwidth(num: number): CharWidth {\n    if (num < 32) return 0;\n    if (num < 127) return 1;\n    if (num < 65536) return table[num] as CharWidth;\n    if (bisearch(num, HIGH_COMBINING)) return 0;\n    if ((num >= 0x20000 && num <= 0x2fffd) || (num >= 0x30000 && num <= 0x3fffd)) return 2;\n    return 1;\n}","import { parse } from \"shell-quote\";\nimport ansiRegex from \"./ansi-regex\";\nimport { wcwidth } from \"./unicode\";\n\n/**\n * Detects all the word boundaries on the given input\n */\nexport function wordBoundaries(input: string, leftSide = true) {\n  let match;\n  const words = [];\n  const rx = /\\w+/g;\n\n  while ((match = rx.exec(input))) {\n    if (leftSide) {\n      words.push(match.index);\n    } else {\n      words.push(match.index + match[0].length);\n    }\n  }\n\n  return words;\n}\n\n/**\n * The closest left (or right) word boundary of the given input at the\n * given offset.\n */\nexport function closestLeftBoundary(input: string, offset: number) {\n  const found = wordBoundaries(input, true)\n    .reverse()\n    .find((x) => x < offset);\n  return found == null ? 0 : found;\n}\nexport function closestRightBoundary(input: string, offset: number) {\n  const found = wordBoundaries(input, false).find((x) => x > offset);\n  return found == null ? input.length : found;\n}\n\n/**\n * Convert offset at the given input to col/row location\n *\n * This function is not optimized and practically emulates via brute-force\n * the navigation on the terminal, wrapping when they reach the column width.\n */\nexport function offsetToColRow(input: string, offset: number, maxCols: number) {\n  let row = 0, col = 0;\n  for (let i = 0; i < offset; ++i) {\n    const chr = input.charAt(i);\n    if (chr === \"\\n\") {\n      col = 0;\n      row += 1;\n    } else {\n      col += 1;\n      if (col === maxCols) {\n        col = 0;\n        row += 1;\n      }\n    }\n  }\n\n  return { row, col };\n}\n\n/**\n * Covert tabs (\\t) to spaces.\n * @param input \n * @returns \n */\nexport function replaceTabToSpace(input: string) {\n  let output = \"\";\n  let col = 0;\n  for (const i of input) {\n    if (i === \"\\t\") {\n      const spaces = 8 - col % 8;\n      output += ' '.repeat(spaces);\n      col += spaces;\n    } else {\n      output += i;\n      col += 1;\n      if (i === \"\\n\") {\n        col = 0;\n      }\n    }\n  }\n  return output;\n}\n\n/**\n * Enumerate each char in @c input, check if it is double-width.\n * If so, add a space after it to align the cursor.\n * \n * @param input \n * @param maxCols \n * @returns \n */\nexport function parseUnicode(input: string, maxCols: number) {\n  let output = \"\";\n  let col = 0;\n  for (let i = 0; i < input.length; ++i) {\n    const width = wcwidth(input.charCodeAt(i));\n    if (width === 0) {\n      if (input[i] === \"\\n\") {\n        col = 0;\n      }\n      continue;\n    } else if (width === 2) {\n      if (col + width > maxCols) {\n        output += ' ';\n        col += 1;\n        i--;\n      } else {\n        output += input[i];\n        output += ' ';\n        col += width;\n      }\n    } else {\n      output += input[i];\n      col += width;\n    }\n    if (col === maxCols) {\n      col = 0;\n    }\n  }\n  return output;\n}\n\n\n/**\n * Counts the lines in the given input\n */\nexport function countLines(input: string, maxCols: number) {\n  return (\n    offsetToColRow(input, input.replace(ansiRegex(), \"\").length, maxCols).row +\n    1\n  );\n}\n\n/**\n * Checks if there is an incomplete input\n *\n * An incomplete input is considered:\n * - An input that contains unterminated single quotes\n * - An input that contains unterminated double quotes\n * - An input that ends with \"\\\"\n * - An input that has an incomplete boolean shell expression (&& and ||)\n * - An incomplete pipe expression (|)\n */\nexport function isIncompleteInput(input: string) {\n  // Empty input is not incomplete\n  if (input.trim() == \"\") {\n    return false;\n  }\n\n  // Check for dangling single-quote strings\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling double-quote strings\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling boolean or pipe operations\n  if (\n    input\n      .split(/(\\|\\||\\||&&)/g)\n      .pop()\n      ?.trim() == \"\"\n  ) {\n    return true;\n  }\n  // Check for tailing slash\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the expression ends on a tailing whitespace\n */\nexport function hasTailingWhitespace(input: string) {\n  return input.match(/[^\\\\][ \\t]$/m) != null;\n}\n\n/**\n * Returns the last expression in the given input\n */\nexport function getLastToken(input: string): string {\n  // Empty expressions\n  if (input.trim() === \"\") return \"\";\n  if (hasTailingWhitespace(input)) return \"\";\n\n  // Last token\n  const tokens = parse(input) as string[];\n  return tokens.pop() || \"\";\n}\n\n/**\n * Returns the auto-complete candidates for the given input\n */\nexport function collectAutocompleteCandidates(\n  callbacks: any[],\n  input: string\n): string[] {\n  const tokens = parse(input);\n  let index = tokens.length - 1;\n  let expr = (tokens[index] as string) || \"\";\n\n  // Empty expressions\n  if (input.trim() === \"\") {\n    index = 0;\n    expr = \"\";\n  } else if (hasTailingWhitespace(input)) {\n    // Expressions with danging space\n    index += 1;\n    expr = \"\";\n  }\n\n  // Collect all auto-complete candidates from the callbacks\n  const all = callbacks.reduce((candidates, { fn, args }) => {\n    try {\n      return candidates.concat(fn(index, tokens, ...args));\n    } catch (e) {\n      console.error(\"Auto-complete error:\", e);\n      return candidates;\n    }\n  }, []);\n\n  // Filter only the ones starting with the expression\n  return all.filter((txt: string) => txt.startsWith(expr));\n}\n\nexport function getSharedFragment(\n  fragment: string,\n  candidates: string[]\n): string | null {\n  // end loop when fragment length = first candidate length\n  if (fragment.length >= candidates[0].length) return fragment;\n\n  // save old fragemnt\n  const oldFragment = fragment;\n\n  // get new fragment\n  fragment += candidates[0].slice(fragment.length, fragment.length + 1);\n\n  for (let i = 0; i < candidates.length; i++) {\n    // return null when there's a wrong candidate\n    if (!candidates[i].startsWith(oldFragment)) return null;\n\n    if (!candidates[i].startsWith(fragment)) {\n      return oldFragment;\n    }\n  }\n\n  return getSharedFragment(fragment, candidates);\n}\n","import type { Terminal, ITerminalAddon, IDisposable } from \"xterm\";\nimport ansiRegex from \"./ansi-regex\";\n\nimport { HistoryController } from \"./HistoryController\";\nimport {\n  closestLeftBoundary,\n  closestRightBoundary,\n  collectAutocompleteCandidates,\n  countLines,\n  getLastToken,\n  hasTailingWhitespace,\n  isIncompleteInput,\n  offsetToColRow,\n  getSharedFragment,\n  replaceTabToSpace,\n  parseUnicode,\n} from \"./Utils\";\nimport { IoEventTarget } from './event';\n\ninterface Size {\n  cols: number;\n  rows: number;\n}\n\ninterface ActivePrompt {\n  prompt: string;\n  continuationPrompt?: string;\n  resolve: any;\n  reject: any;\n}\n\ninterface AutoCompleteHandler {\n  fn: Function;\n  args: any[];\n}\n\nexport interface Option {\n  historySize: number;\n  enableAutocomplete: boolean;\n  maxAutocompleteEntries: number;\n  enableIncompleteInput: boolean;\n}\n\nexport class LocalEchoAddon extends IoEventTarget implements ITerminalAddon {\n  constructor(option?: Partial<Option>) {\n    super();\n    this.history = new HistoryController(option?.historySize ?? 10);\n    this.enableAutocomplete = option?.enableAutocomplete ?? true;\n    this.maxAutocompleteEntries = option?.maxAutocompleteEntries ?? 100;\n    this.enableIncompleteInput = option?.enableIncompleteInput ?? true;\n  }\n\n  public history: HistoryController;\n\n  private terminal!: Terminal;\n  private disposables: IDisposable[] = [];\n\n  private enableAutocomplete: boolean;\n  private maxAutocompleteEntries: number;\n\n  private enableIncompleteInput: boolean;\n\n  private autocompleteHandlers: AutoCompleteHandler[] = [];\n  private active = false;\n  private input = \"\";\n  private cursor = 0;\n  private activePrompt: ActivePrompt | null = null;\n  private activeCharPrompt: ActivePrompt | null = null;\n\n  private writingPromise: Promise<void> | null = null;\n\n  private remainKeys: string = \"\";\n\n  private terminalSize: Size = {\n    cols: 0,\n    rows: 0,\n  };\n\n  public activate(terminal: Terminal): void {\n    this.terminal = terminal;\n    this.attach();\n  }\n\n  public dispose(): void {\n    this.detach();\n  }\n\n  /**\n   * Register a handler that will be called to satisfy auto-completion\n   */\n  public addAutocompleteHandler(fn: Function, ...args: any[]) {\n    this.autocompleteHandlers.push({\n      fn,\n      args,\n    });\n  }\n\n  /**\n   * Remove a previously registered auto-complete handler\n   */\n  public removeAutocompleteHandler(fn: Function) {\n    const idx = this.autocompleteHandlers.findIndex((e) => e.fn === fn);\n    if (idx === -1) return;\n\n    this.autocompleteHandlers.splice(idx, 1);\n  }\n\n  /**\n   * Return a promise that will resolve when the user has completed\n   * typing a single line\n   */\n  public async read(prompt?: string, continuationPrompt = \"> \") {\n    await this.writingPromise;\n    return new Promise<string>((resolve, reject) => {\n      if (typeof prompt === \"undefined\") {\n        const row = this.terminal.buffer.active.cursorY;\n        const col = this.terminal.buffer.active.cursorX;\n        this.terminal.select(0, row, col);\n        prompt = this.terminal.getSelection();\n        this.terminal.clearSelection();\n      } else {\n        this.terminal.write(prompt);\n      }\n      this.activePrompt = {\n        prompt,\n        continuationPrompt,\n        resolve,\n        reject,\n      };\n\n      this.input = \"\";\n      this.cursor = 0;\n      this.active = true;\n\n      if (this.remainKeys.length > 0) {\n        this.handleTermData(this.remainKeys);\n      }\n    });\n  }\n\n  /**\n   * Return a promise that will be resolved when the user types a single\n   * character.\n   *\n   * This can be active in addition to `.read()` and will be resolved in\n   * priority before it.\n   */\n  readChar(prompt: string) {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(prompt);\n      this.activeCharPrompt = {\n        prompt,\n        resolve,\n        reject,\n      };\n    });\n  }\n\n  /**\n   * Abort a pending read operation\n   */\n  abortRead(reason = \"aborted\") {\n    if (this.activePrompt != null || this.activeCharPrompt != null) {\n      this.terminal.write(\"\\r\\n\");\n    }\n    if (this.activePrompt != null) {\n      this.activePrompt.reject(reason);\n      this.activePrompt = null;\n    }\n    if (this.activeCharPrompt != null) {\n      this.activeCharPrompt.reject(reason);\n      this.activeCharPrompt = null;\n    }\n    this.active = false;\n  }\n\n  /**\n   * Prints a message and changes line\n   */\n  async println(message: string) {\n    return this.print(message + \"\\n\");\n  }\n\n  /**\n   * Prints a message and properly handles new-lines\n   */\n  async print(message: string) {\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\n    this.writingPromise = this.internalWrite(normInput.replace(/\\n/g, \"\\r\\n\"));\n    return this.writingPromise;\n  }\n\n  /**\n   * Prints a list of items using a wide-format\n   */\n  printWide(items: string[], padding = 2) {\n    if (items.length == 0) return this.println(\"\");\n\n    // Compute item sizes and matrix row/cols\n    const itemWidth =\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\n    const wideCols = Math.floor(this.terminalSize.cols / itemWidth);\n    const wideRows = Math.ceil(items.length / wideCols);\n\n    // Print matrix\n    let i = 0;\n    for (let row = 0; row < wideRows; ++row) {\n      let rowStr = \"\";\n\n      // Prepare columns\n      for (let col = 0; col < wideCols; ++col) {\n        if (i < items.length) {\n          let item = items[i++];\n          item += \" \".repeat(itemWidth - item.length);\n          rowStr += item;\n        }\n      }\n      this.println(rowStr);\n    }\n  }\n\n  private attach() {\n    if (!this.terminal) return;\n    this.disposables.push(\n      this.terminal.onData((data) => this.handleTermData(data))\n    );\n    this.disposables.push(\n      this.terminal.onResize((size) => this.handleTermResize(size))\n    );\n\n    this.terminalSize = {\n      cols: this.terminal.cols,\n      rows: this.terminal.rows,\n    };\n  }\n\n  private detach() {\n    this.disposables.forEach((d) => d.dispose());\n    this.disposables = [];\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Internal API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /** Calls terminal.write, but promisify */\n  private async internalWrite(data: string | Uint8Array) {\n    return new Promise<void>((resolve) => {\n      this.terminal.write(data, resolve);\n    });\n  }\n\n  /**\n   * Apply prompts to the given input\n   */\n  private applyPrompts(input: string) {\n    const prompt = (this.activePrompt || {}).prompt || \"\";\n    const continuationPrompt =\n      (this.activePrompt || {}).continuationPrompt || \"\";\n\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n  }\n\n  /**\n   * Advances the `offset` as required in order to accompany the prompt\n   * additions to the input.\n   */\n  private applyPromptOffset(input: string, offset: number) {\n    let newInput = this.applyPrompts(input.substring(0, offset));\n    newInput = this.toSingleWidth(newInput);\n    return newInput.replace(ansiRegex(), \"\").length;\n  }\n\n  /** Combine tab->space and CJK->space conversion. This make cursor calculation correct. */ \n  private toSingleWidth = (str: string) => parseUnicode(replaceTabToSpace(str), this.terminal.cols);\n\n  /**\n   * Clears the current prompt\n   *\n   * This function will erase all the lines that display the current prompt\n   * and move the cursor in the beginning of the first line of the prompt.\n   */\n  private clearInput() {\n    const currentPrompt = this.toSingleWidth(this.applyPrompts(this.input));\n\n    // Get the overall number of lines to clear\n    const allRows = countLines(currentPrompt, this.terminalSize.cols);\n\n    // Get the line we are currently in\n    const promptCursor = this.applyPromptOffset(this.input, this.cursor);\n    const { col, row } = offsetToColRow(\n      currentPrompt,\n      promptCursor,\n      this.terminalSize.cols\n    );\n\n    // First move on the last line\n    const moveRows = allRows - row - 1;\n\n    // console.log('clear: ', { col, row, moveRows });\n\n    // negative, move up\n    for (let i = moveRows; i < 0; ++i) this.terminal.write(\"\\x1B[2K\\x1B[F\");\n    // positive, move down\n    for (let i = 0; i < moveRows; ++i) this.terminal.write(\"\\x1B[E\");\n\n    // Clear current input line(s)\n    this.terminal.write(\"\\r\\x1B[K\");\n    for (let i = 1; i < allRows; ++i) this.terminal.write(\"\\x1B[F\\x1B[K\");\n  }\n\n  /**\n   * Replace input with the new input given\n   *\n   * This function clears all the lines that the current input occupies and\n   * then replaces them with the new input.\n   */\n  private setInput(newInput: string, clearInput = true) {\n    // Clear current input\n    if (clearInput) this.clearInput();\n\n    // Write the new input lines, including the current prompt\n    // Need to replace tab here, for new-line compatibility\n    let newPrompt = replaceTabToSpace(this.applyPrompts(newInput));\n    this.print(newPrompt);\n    newPrompt = this.toSingleWidth(newPrompt);\n\n    // Trim cursor overflow\n    if (this.cursor > newInput.length) {\n      this.cursor = newInput.length;\n    }\n\n    // Move the cursor to the appropriate row/col\n    const newCursor = this.applyPromptOffset(newInput, this.cursor);\n    const newLines = countLines(newPrompt, this.terminalSize.cols);\n    const { col, row } = offsetToColRow(\n      newPrompt,\n      newCursor,\n      this.terminalSize.cols\n    );\n    const moveUpRows = newLines - row - 1;\n\n    // console.log({ col, row, moveUpRows });\n\n    // xterm keep the cursor on last column when it is at the end of the line.\n    // Move it to next line.\n    if (row !== 0 && col === 0) this.terminal.write(\"\\x1B[E\");\n\n    this.terminal.write(\"\\r\");\n    for (let i = 0; i < moveUpRows; ++i) this.terminal.write(\"\\x1B[F\");\n    for (let i = 0; i < col; ++i) this.terminal.write(\"\\x1B[C\");\n\n    // Replace input\n    this.input = newInput;\n  }\n\n  /**\n   * This function completes the current input, calls the given callback\n   * and then re-displays the prompt.\n   */\n  private printAndRestartPrompt(callback: any) {\n    const cursor = this.cursor;\n\n    // Complete input\n    this.setCursor(this.input.length);\n    this.terminal.write(\"\\r\\n\");\n\n    // Prepare a function that will resume prompt\n    const resume = () => {\n      this.cursor = cursor;\n      this.setInput(this.input);\n    };\n\n    // Call the given callback to echo something, and if there is a promise\n    // returned, wait for the resolution before resuming prompt.\n    const ret = callback();\n    if (ret == null) {\n      resume();\n    } else {\n      ret.then(resume);\n    }\n  }\n\n  /**\n   * Set the new cursor position, as an offset on the input string\n   *\n   * This function:\n   * - Calculates the previous and current\n   */\n  private setCursor(newCursor: number) {\n    if (newCursor < 0) newCursor = 0;\n    if (newCursor > this.input.length) newCursor = this.input.length;\n\n    // Apply prompt formatting to get the visual status of the display\n    const inputWithPrompt = this.applyPrompts(this.input);\n\n    // Estimate previous cursor position\n    const prevPromptOffset = this.applyPromptOffset(this.input, this.cursor);\n    const { col: prevCol, row: prevRow } = offsetToColRow(\n      inputWithPrompt,\n      prevPromptOffset,\n      this.terminalSize.cols\n    );\n\n    // Estimate next cursor position\n    const newPromptOffset = this.applyPromptOffset(this.input, newCursor);\n    const { col: newCol, row: newRow } = offsetToColRow(\n      inputWithPrompt,\n      newPromptOffset,\n      this.terminalSize.cols\n    );\n\n    // Adjust vertically\n    if (newRow > prevRow) {\n      for (let i = prevRow; i < newRow; ++i) this.terminal.write(\"\\x1B[B\");\n    } else {\n      for (let i = newRow; i < prevRow; ++i) this.terminal.write(\"\\x1B[A\");\n    }\n\n    // Adjust horizontally\n    if (newCol > prevCol) {\n      for (let i = prevCol; i < newCol; ++i) this.terminal.write(\"\\x1B[C\");\n    } else {\n      for (let i = newCol; i < prevCol; ++i) this.terminal.write(\"\\x1B[D\");\n    }\n\n    // Set new offset\n    this.cursor = newCursor;\n  }\n\n  /**\n   * Move cursor at given direction\n   */\n  private handleCursorMove(dir: number) {\n    if (dir > 0) {\n      const num = Math.min(dir, this.input.length - this.cursor);\n      this.setCursor(this.cursor + num);\n    } else if (dir < 0) {\n      const num = Math.max(dir, -this.cursor);\n      this.setCursor(this.cursor + num);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   */\n  private handleCursorErase(backspace: boolean) {\n    if (backspace) {\n      if (this.cursor <= 0) return;\n      const newInput =\n        this.input.substring(0, this.cursor - 1) + this.input.substring(this.cursor);\n      this.clearInput();\n      this.cursor -= 1;\n      this.setInput(newInput, false);\n    } else {\n      const newInput =\n        this.input.substring(0, this.cursor) + this.input.substring(this.cursor + 1);\n      this.setInput(newInput);\n    }\n  }\n\n  /**\n   * Insert character at cursor location\n   */\n  private handleCursorInsert(data: string) {\n    const newInput =\n      this.input.substring(0, this.cursor) + data + this.input.substring(this.cursor);\n    this.cursor += data.length;\n    this.setInput(newInput);\n  }\n\n  /**\n   * Handle input completion\n   */\n  private async handleReadComplete() {\n    if (this.history) {\n      this.history.push(this.input);\n    }\n    await this.internalWrite(\"\\r\\n\");\n    if (this.activePrompt) {\n      this.activePrompt.resolve(this.input);\n      this.activePrompt = null;\n    }\n    this.active = false;\n  }\n\n  /**\n   * Handle terminal resize\n   *\n   * This function clears the prompt using the previous configuration,\n   * updates the cached terminal size information and then re-renders the\n   * input. This leads (most of the times) into a better formatted input.\n   */\n  private handleTermResize(data: Size) {\n    const { rows, cols } = data;\n    this.clearInput();\n    this.terminalSize = { cols, rows };\n    this.setInput(this.input, false);\n  }\n\n  /**\n   * Handle terminal input\n   */\n  private handleTermData(data: string) {\n    if (!this.active) return;\n    if (data.length === 0) return;\n\n    // If we have an active character prompt, satisfy it in priority\n    if (this.activeCharPrompt != null) {\n      this.activeCharPrompt.resolve(data);\n      this.activeCharPrompt = null;\n      this.terminal.write(\"\\r\\n\");\n      return;\n    }\n\n    // Looks like a pasted input.\n    // Handle a line, then put another to this.remainKeys.\n    // When next read call comes, we'll handle them.\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n      for (let i = 0; i < data.length; i++) {\n        this.handleData(data[i]);\n        if (data[i] === '\\r') {\n          this.remainKeys = data.substring(i + 1);\n          break;\n        }\n      }\n    } else {\n      this.handleData(data);\n      this.remainKeys = \"\";\n    }\n  }\n\n  /**\n   * Handle a single piece of information from the terminal.\n   */\n  private handleData(data: string) {\n    if (!this.active) return;\n    const ord = data.charCodeAt(0);\n    let ofs;\n\n    // Handle ANSI escape sequences\n    if (ord == 0x1b) {\n      switch (data.substring(1)) {\n        case \"[A\": // Up arrow\n          if (this.history) {\n            const value = this.history.getPrevious();\n            if (value) {\n              this.setInput(value);\n              this.setCursor(value.length);\n            }\n          }\n          break;\n\n        case \"[B\": // Down arrow\n          if (this.history) {\n            let value = this.history.getNext();\n            if (!value) value = \"\";\n            this.setInput(value);\n            this.setCursor(value.length);\n          }\n          break;\n\n        case \"[D\": // Left Arrow\n          this.handleCursorMove(-1);\n          break;\n\n        case \"[C\": // Right Arrow\n          this.handleCursorMove(1);\n          break;\n\n        case \"[3~\": // Delete\n          this.handleCursorErase(false);\n          break;\n\n        case \"[F\": // End\n          this.setCursor(this.input.length);\n          break;\n\n        case \"[H\": // Home\n          this.setCursor(0);\n          break;\n\n        case \"b\": // ALT + LEFT\n          ofs = closestLeftBoundary(this.input, this.cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"f\": // ALT + RIGHT\n          ofs = closestRightBoundary(this.input, this.cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"\\x7F\": // CTRL + BACKSPACE\n          ofs = closestLeftBoundary(this.input, this.cursor);\n          if (ofs != null) {\n            this.setInput(\n              this.input.substring(0, ofs) + this.input.substring(this.cursor)\n            );\n            this.setCursor(ofs);\n          }\n          break;\n      }\n\n      // Handle special characters\n    } else if (ord < 32 || ord === 0x7f) {\n      switch (data) {\n        case \"\\r\": // ENTER\n          if (this.enableIncompleteInput && isIncompleteInput(this.input)) {\n            this.handleCursorInsert(\"\\n\");\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        case \"\\x7F\": // BACKSPACE\n          this.handleCursorErase(true);\n          break;\n\n        case \"\\t\": // TAB\n          if (this.enableAutocomplete) {\n            if (this.autocompleteHandlers.length > 0) {\n              const inputFragment = this.input.substring(0, this.cursor);\n              const hasTailingSpace = hasTailingWhitespace(inputFragment);\n              const candidates = collectAutocompleteCandidates(\n                this.autocompleteHandlers,\n                inputFragment\n              );\n\n              // Sort candidates\n              candidates.sort();\n\n              // Depending on the number of candidates, we are handing them in\n              // a different way.\n              if (candidates.length === 0) {\n                // No candidates? Just add a space if there is none already\n                if (!hasTailingSpace) {\n                  this.handleCursorInsert(\" \");\n                }\n              } else if (candidates.length === 1) {\n                // Just a single candidate? Complete\n                const lastToken = getLastToken(inputFragment);\n                this.handleCursorInsert(\n                  candidates[0].substring(lastToken.length) + \" \"\n                );\n              } else if (candidates.length <= this.maxAutocompleteEntries) {\n                // search for a shared fragement\n                const sameFragment = getSharedFragment(inputFragment, candidates);\n\n                // if there's a shared fragement between the candidates\n                // print complete the shared fragment\n                if (sameFragment) {\n                  const lastToken = getLastToken(inputFragment);\n                  this.handleCursorInsert(sameFragment.substring(lastToken.length));\n                }\n\n                // If we are less than maximum auto-complete candidates, print\n                // them to the user and re-start prompt\n                this.printAndRestartPrompt(() => {\n                  this.printWide(candidates);\n                });\n              } else {\n                // If we have more than maximum auto-complete candidates, print\n                // them only if the user acknowledges a warning\n                this.printAndRestartPrompt(() =>\n                  this.readChar(\n                    `Display all ${candidates.length} possibilities? (y or n)`\n                  ).then((yn) => {\n                    if (yn == \"y\" || yn == \"Y\") {\n                      this.printWide(candidates);\n                    }\n                  })\n                );\n              }\n            }\n          } else {\n            this.handleCursorInsert(\"\\t\");\n          }\n          break;\n\n        case \"\\x03\": // CTRL+C\n          this.setCursor(this.input.length);\n          this.terminal.write(\n            \"^C\\r\\n\" + ((this.activePrompt || {}).prompt || \"\")\n          );\n          this.input = \"\";\n          this.cursor = 0;\n          if (this.history) this.history.rewind();\n          this.emitInterrupt();\n          break;\n\n        case \"\\x04\": // CTRL+D\n          this.setCursor(this.input.length);\n          this.terminal.write(\n            \"^D\\r\\n\" + ((this.activePrompt || {}).prompt || \"\")\n          );\n          this.input = \"\";\n          this.cursor = 0;\n          if (this.history) this.history.rewind();\n          this.abortRead();\n          this.emitEof();\n          break;\n      }\n\n      // Handle visible characters\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n}\n","export class IoEventTarget extends EventTarget {\n    emitEof() {\n        this.dispatchEvent(new Event('eof'));\n    }\n    emitInterrupt() {\n        this.dispatchEvent(new Event('interrupt'));\n    }\n    onEof(callback: (e: Event) => void) {\n        this.addEventListener('eof', callback);\n    }\n    onInterrupt(callback: (e: Event) => void) {\n        this.addEventListener('interrupt', callback);\n    }\n}"],"names":["ansiRegex","onlyFirst","pattern","join","RegExp","undefined","HistoryController","size","entries","cursor","this","push","entry","trim","length","shift","rewind","getPrevious","idx","Math","max","getNext","min","CONTROL","TOKEN","i","pow","random","toString","s","env","opts","mapped","chunker","match","filter","Boolean","commented","map","j","test","op","BS","escape","quote","esc","out","isGlob","len","c","charAt","parseEnvVar","comment","slice","varend","varname","Error","substr","indexOf","index","_","pre","key","r","JSON","stringify","getVar","reduce","prev","arg","concat","parse","acc","xs","split","x","BMP_COMBINING","HIGH_COMBINING","table","Uint8Array","fill","wordBoundaries","input","leftSide","words","rx","exec","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","row","col","replaceTabToSpace","output","spaces","repeat","countLines","replace","hasTailingWhitespace","getLastToken","pop","getSharedFragment","fragment","candidates","oldFragment","startsWith","LocalEchoAddon","option","_this","history","terminal","disposables","enableAutocomplete","maxAutocompleteEntries","enableIncompleteInput","autocompleteHandlers","active","activePrompt","activeCharPrompt","writingPromise","remainKeys","terminalSize","cols","rows","toSingleWidth","str","num","width","charCodeAt","ucs","data","mid","bisearch","parseUnicode","historySize","activate","attach","dispose","detach","addAutocompleteHandler","fn","args","removeAutocompleteHandler","findIndex","e","splice","read","prompt","continuationPrompt","_this3","Promise","resolve","reject","select","buffer","cursorY","cursorX","getSelection","clearSelection","write","handleTermData","readChar","_this4","abortRead","reason","println","message","print","normInput","_this8","internalWrite","printWide","items","padding","itemWidth","item","wideCols","floor","wideRows","ceil","rowStr","onData","_this9","onResize","handleTermResize","forEach","d","_this11","applyPrompts","applyPromptOffset","newInput","substring","clearInput","currentPrompt","allRows","moveRows","setInput","newPrompt","newCursor","newLines","moveUpRows","printAndRestartPrompt","callback","setCursor","resume","_this12","ret","then","inputWithPrompt","prevCol","prevRow","newCol","newRow","handleCursorMove","dir","handleCursorErase","backspace","handleCursorInsert","handleReadComplete","_this14","handleData","ofs","ord","value","endsWith","isIncompleteInput","inputFragment","hasTailingSpace","callbacks","tokens","expr","console","error","txt","collectAutocompleteCandidates","sort","lastToken","sameFragment","_this15","yn","emitInterrupt","emitEof","dispatchEvent","Event","onEof","addEventListener","onInterrupt","EventTarget"],"mappings":"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KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ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"}