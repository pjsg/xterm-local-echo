{"version":3,"file":"index.modern.js","sources":["../src/ansi-regex.ts","../src/HistoryController.ts","../node_modules/shell-quote/index.js","../src/unicode.ts","../src/Utils.ts","../src/event.ts","../src/index.ts"],"sourcesContent":["// I don't know why npm install doesn't load it\n// https://github.com/chalk/ansi-regex/\nexport default function ansiRegex({ onlyFirst = false } = {}) {\n  const pattern = [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\n  ].join(\"|\");\n\n  return new RegExp(pattern, onlyFirst ? undefined : \"g\");\n}\n","/**\n * The history controller provides an ring-buffer\n */\nexport class HistoryController {\n  constructor(private size: number) {}\n\n  public entries: string[] = [];\n  private cursor = 0;\n\n  /**\n   * Push an entry and maintain ring buffer size\n   */\n  push(entry: string): void {\n    // Skip empty entries\n    if (entry.trim() === \"\") return;\n    // Skip duplicate entries\n    const lastEntry = this.entries[this.entries.length - 1];\n    if (entry === lastEntry) {\n      this.cursor = this.entries.length;\n      return;\n    }\n    // Keep track of entries\n    this.entries.push(entry);\n    if (this.entries.length > this.size) {\n      this.entries.shift();\n    }\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Rewind history cursor on the last entry\n   */\n  rewind(): void {\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Returns the previous entry\n   */\n  getPrevious(): string {\n    const idx = Math.max(0, this.cursor - 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n\n  /**\n   * Returns the next entry\n   */\n  getNext(): string {\n    const idx = Math.min(this.entries.length, this.cursor + 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n}\n","exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n","// https://github.com/xtermjs/xterm.js/blob/master/src/common/input/UnicodeV6.ts\n\ntype CharWidth = 0 | 1 | 2;\n\nconst BMP_COMBINING = [\n    [0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489],\n    [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2],\n    [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603],\n    [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670],\n    [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED],\n    [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A],\n    [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902],\n    [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D],\n    [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981],\n    [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD],\n    [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C],\n    [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D],\n    [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC],\n    [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD],\n    [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C],\n    [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D],\n    [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0],\n    [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48],\n    [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC],\n    [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD],\n    [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D],\n    [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6],\n    [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E],\n    [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC],\n    [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35],\n    [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E],\n    [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97],\n    [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030],\n    [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039],\n    [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F],\n    [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753],\n    [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD],\n    [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD],\n    [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922],\n    [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B],\n    [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34],\n    [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42],\n    [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF],\n    [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063],\n    [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F],\n    [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B],\n    [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F],\n    [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB]\n];\nconst HIGH_COMBINING = [\n    [0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F],\n    [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169],\n    [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD],\n    [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F],\n    [0xE0100, 0xE01EF]\n];\n\n// BMP lookup table, lazy initialized during first addon loading\nlet table = new Uint8Array(65536);\n\nfunction bisearch(ucs: number, data: number[][]): boolean {\n    let min = 0;\n    let max = data.length - 1;\n    let mid;\n    if (ucs < data[0][0] || ucs > data[max][1]) {\n        return false;\n    }\n    while (max >= min) {\n        mid = (min + max) >> 1;\n        if (ucs > data[mid][1]) {\n            min = mid + 1;\n        } else if (ucs < data[mid][0]) {\n            max = mid - 1;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n// init lookup table once\ntable.fill(1);\ntable[0] = 0;\n// control chars\ntable.fill(0, 1, 32);\ntable.fill(0, 0x7f, 0xa0);\n\n// apply wide char rules first\n// wide chars\ntable.fill(2, 0x1100, 0x1160);\ntable[0x2329] = 2;\ntable[0x232a] = 2;\ntable.fill(2, 0x2e80, 0xa4d0);\ntable[0x303f] = 1;  // wrongly in last line\n\ntable.fill(2, 0xac00, 0xd7a4);\ntable.fill(2, 0xf900, 0xfb00);\ntable.fill(2, 0xfe10, 0xfe1a);\ntable.fill(2, 0xfe30, 0xfe70);\ntable.fill(2, 0xff00, 0xff61);\ntable.fill(2, 0xffe0, 0xffe7);\n\n// apply combining last to ensure we overwrite\n// wrongly wide set chars:\n//    the original algo evals combining first and falls\n//    through to wide check so we simply do here the opposite\n// combining 0\nfor (let r = 0; r < BMP_COMBINING.length; ++r) {\n    table.fill(0, BMP_COMBINING[r][0], BMP_COMBINING[r][1] + 1);\n}\n\nexport function wcwidth(num: number): CharWidth {\n    if (num < 32) return 0;\n    if (num < 127) return 1;\n    if (num < 65536) return table[num] as CharWidth;\n    if (bisearch(num, HIGH_COMBINING)) return 0;\n    if ((num >= 0x20000 && num <= 0x2fffd) || (num >= 0x30000 && num <= 0x3fffd)) return 2;\n    return 1;\n}","import { parse } from \"shell-quote\";\nimport ansiRegex from \"./ansi-regex\";\nimport { wcwidth } from \"./unicode\";\n\n/**\n * Detects all the word boundaries on the given input\n */\nexport function wordBoundaries(input: string, leftSide = true) {\n  let match;\n  const words = [];\n  const rx = /\\w+/g;\n\n  while ((match = rx.exec(input))) {\n    if (leftSide) {\n      words.push(match.index);\n    } else {\n      words.push(match.index + match[0].length);\n    }\n  }\n\n  return words;\n}\n\n/**\n * The closest left (or right) word boundary of the given input at the\n * given offset.\n */\nexport function closestLeftBoundary(input: string, offset: number) {\n  const found = wordBoundaries(input, true)\n    .reverse()\n    .find((x) => x < offset);\n  return found == null ? 0 : found;\n}\nexport function closestRightBoundary(input: string, offset: number) {\n  const found = wordBoundaries(input, false).find((x) => x > offset);\n  return found == null ? input.length : found;\n}\n\n/**\n * Convert offset at the given input to col/row location\n *\n * This function is not optimized and practically emulates via brute-force\n * the navigation on the terminal, wrapping when they reach the column width.\n */\nexport function offsetToColRow(input: string, offset: number, maxCols: number) {\n  let row = 0, col = 0;\n  for (let i = 0; i < offset; ++i) {\n    const chr = input.charAt(i);\n    if (chr === \"\\n\") {\n      col = 0;\n      row += 1;\n    } else {\n      col += 1;\n      if (col === maxCols) {\n        col = 0;\n        row += 1;\n      }\n    }\n  }\n\n  return { row, col };\n}\n\n/**\n * Covert tabs (\\t) to spaces.\n * @param input \n * @returns \n */\nexport function replaceTabToSpace(input: string) {\n  let output = \"\";\n  let col = 0;\n  for (const i of input) {\n    if (i === \"\\t\") {\n      const spaces = 8 - col % 8;\n      output += ' '.repeat(spaces);\n      col += spaces;\n    } else {\n      output += i;\n      col += 1;\n      if (i === \"\\n\") {\n        col = 0;\n      }\n    }\n  }\n  return output;\n}\n\n/**\n * Enumerate each char in @c input, check if it is double-width.\n * If so, add a space after it to align the cursor.\n * \n * @param input \n * @param maxCols \n * @returns \n */\nexport function parseUnicode(input: string, maxCols: number) {\n  let output = \"\";\n  let col = 0;\n  for (let i = 0; i < input.length; ++i) {\n    const width = wcwidth(input.charCodeAt(i));\n    if (width === 0) {\n      if (input[i] === \"\\n\") {\n        col = 0;\n      }\n      continue;\n    } else if (width === 2) {\n      if (col + width > maxCols) {\n        output += ' ';\n        col += 1;\n        i--;\n      } else {\n        output += input[i];\n        output += ' ';\n        col += width;\n      }\n    } else {\n      output += input[i];\n      col += width;\n    }\n    if (col === maxCols) {\n      col = 0;\n    }\n  }\n  return output;\n}\n\n\n/**\n * Counts the lines in the given input\n */\nexport function countLines(input: string, maxCols: number) {\n  return (\n    offsetToColRow(input, input.replace(ansiRegex(), \"\").length, maxCols).row +\n    1\n  );\n}\n\n/**\n * Checks if there is an incomplete input\n *\n * An incomplete input is considered:\n * - An input that contains unterminated single quotes\n * - An input that contains unterminated double quotes\n * - An input that ends with \"\\\"\n * - An input that has an incomplete boolean shell expression (&& and ||)\n * - An incomplete pipe expression (|)\n */\nexport function isIncompleteInput(input: string) {\n  // Empty input is not incomplete\n  if (input.trim() == \"\") {\n    return false;\n  }\n\n  // Check for dangling single-quote strings\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling double-quote strings\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling boolean or pipe operations\n  if (\n    input\n      .split(/(\\|\\||\\||&&)/g)\n      .pop()\n      ?.trim() == \"\"\n  ) {\n    return true;\n  }\n  // Check for tailing slash\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the expression ends on a tailing whitespace\n */\nexport function hasTailingWhitespace(input: string) {\n  return input.match(/[^\\\\][ \\t]$/m) != null;\n}\n\n/**\n * Returns the last expression in the given input\n */\nexport function getLastToken(input: string): string {\n  // Empty expressions\n  if (input.trim() === \"\") return \"\";\n  if (hasTailingWhitespace(input)) return \"\";\n\n  // Last token\n  const tokens = parse(input) as string[];\n  return tokens.pop() || \"\";\n}\n\n/**\n * Returns the auto-complete candidates for the given input\n */\nexport function collectAutocompleteCandidates(\n  callbacks: any[],\n  input: string\n): string[] {\n  const tokens = parse(input);\n  let index = tokens.length - 1;\n  let expr = (tokens[index] as string) || \"\";\n\n  // Empty expressions\n  if (input.trim() === \"\") {\n    index = 0;\n    expr = \"\";\n  } else if (hasTailingWhitespace(input)) {\n    // Expressions with danging space\n    index += 1;\n    expr = \"\";\n  }\n\n  // Collect all auto-complete candidates from the callbacks\n  const all = callbacks.reduce((candidates, { fn, args }) => {\n    try {\n      return candidates.concat(fn(index, tokens, ...args));\n    } catch (e) {\n      console.error(\"Auto-complete error:\", e);\n      return candidates;\n    }\n  }, []);\n\n  // Filter only the ones starting with the expression\n  return all.filter((txt: string) => txt.startsWith(expr));\n}\n\nexport function getSharedFragment(\n  fragment: string,\n  candidates: string[]\n): string | null {\n  // end loop when fragment length = first candidate length\n  if (fragment.length >= candidates[0].length) return fragment;\n\n  // save old fragemnt\n  const oldFragment = fragment;\n\n  // get new fragment\n  fragment += candidates[0].slice(fragment.length, fragment.length + 1);\n\n  for (let i = 0; i < candidates.length; i++) {\n    // return null when there's a wrong candidate\n    if (!candidates[i].startsWith(oldFragment)) return null;\n\n    if (!candidates[i].startsWith(fragment)) {\n      return oldFragment;\n    }\n  }\n\n  return getSharedFragment(fragment, candidates);\n}\n","export class IoEventTarget extends EventTarget {\n    emitEof() {\n        this.dispatchEvent(new Event('eof'));\n    }\n    emitInterrupt() {\n        this.dispatchEvent(new Event('interrupt'));\n    }\n    onEof(callback: (e: Event) => void) {\n        this.addEventListener('eof', callback);\n    }\n    onInterrupt(callback: (e: Event) => void) {\n        this.addEventListener('interrupt', callback);\n    }\n}","import type { Terminal, ITerminalAddon, IDisposable } from \"xterm\";\nimport ansiRegex from \"./ansi-regex\";\n\nimport { HistoryController } from \"./HistoryController\";\nimport {\n  closestLeftBoundary,\n  closestRightBoundary,\n  collectAutocompleteCandidates,\n  countLines,\n  getLastToken,\n  hasTailingWhitespace,\n  isIncompleteInput,\n  offsetToColRow,\n  getSharedFragment,\n  replaceTabToSpace,\n  parseUnicode,\n} from \"./Utils\";\nimport { IoEventTarget } from './event';\n\ninterface Size {\n  cols: number;\n  rows: number;\n}\n\ninterface ActivePrompt {\n  prompt: string;\n  continuationPrompt?: string;\n  resolve: any;\n  reject: any;\n}\n\ninterface AutoCompleteHandler {\n  fn: Function;\n  args: any[];\n}\n\nexport interface Option {\n  historySize: number;\n  enableAutocomplete: boolean;\n  maxAutocompleteEntries: number;\n  enableIncompleteInput: boolean;\n}\n\nexport class LocalEchoAddon extends IoEventTarget implements ITerminalAddon {\n  constructor(option?: Partial<Option>) {\n    super();\n    this.history = new HistoryController(option?.historySize ?? 10);\n    this.enableAutocomplete = option?.enableAutocomplete ?? true;\n    this.maxAutocompleteEntries = option?.maxAutocompleteEntries ?? 100;\n    this.enableIncompleteInput = option?.enableIncompleteInput ?? true;\n  }\n\n  public history: HistoryController;\n\n  private terminal!: Terminal;\n  private disposables: IDisposable[] = [];\n\n  private enableAutocomplete: boolean;\n  private maxAutocompleteEntries: number;\n\n  private enableIncompleteInput: boolean;\n\n  private autocompleteHandlers: AutoCompleteHandler[] = [];\n  private active = false;\n  private input = \"\";\n  private cursor = 0;\n  private activePrompt: ActivePrompt | null = null;\n  private activeCharPrompt: ActivePrompt | null = null;\n\n  private writingPromise: Promise<void> | null = null;\n\n  private remainKeys: string = \"\";\n\n  private terminalSize: Size = {\n    cols: 0,\n    rows: 0,\n  };\n\n  public activate(terminal: Terminal): void {\n    this.terminal = terminal;\n    this.attach();\n  }\n\n  public dispose(): void {\n    this.detach();\n  }\n\n  /**\n   * Register a handler that will be called to satisfy auto-completion\n   */\n  public addAutocompleteHandler(fn: Function, ...args: any[]) {\n    this.autocompleteHandlers.push({\n      fn,\n      args,\n    });\n  }\n\n  /**\n   * Remove a previously registered auto-complete handler\n   */\n  public removeAutocompleteHandler(fn: Function) {\n    const idx = this.autocompleteHandlers.findIndex((e) => e.fn === fn);\n    if (idx === -1) return;\n\n    this.autocompleteHandlers.splice(idx, 1);\n  }\n\n  /**\n   * Return a promise that will resolve when the user has completed\n   * typing a single line\n   */\n  public async read(prompt?: string, continuationPrompt = \"> \") {\n    await this.writingPromise;\n    return new Promise<string>((resolve, reject) => {\n      if (typeof prompt === \"undefined\") {\n        const row = this.terminal.buffer.active.cursorY;\n        const col = this.terminal.buffer.active.cursorX;\n        this.terminal.select(0, row, col);\n        prompt = this.terminal.getSelection();\n        this.terminal.clearSelection();\n      } else {\n        this.terminal.write(prompt);\n      }\n      this.activePrompt = {\n        prompt,\n        continuationPrompt,\n        resolve,\n        reject,\n      };\n\n      this.input = \"\";\n      this.cursor = 0;\n      this.active = true;\n\n      if (this.remainKeys.length > 0) {\n        this.handleTermData(this.remainKeys);\n      }\n    });\n  }\n\n  /**\n   * Return a promise that will be resolved when the user types a single\n   * character.\n   *\n   * This can be active in addition to `.read()` and will be resolved in\n   * priority before it.\n   */\n  readChar(prompt: string) {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(prompt);\n      this.activeCharPrompt = {\n        prompt,\n        resolve,\n        reject,\n      };\n    });\n  }\n\n  /**\n   * Abort a pending read operation\n   */\n  abortRead(reason = \"aborted\") {\n    if (this.activePrompt != null || this.activeCharPrompt != null) {\n      this.terminal.write(\"\\r\\n\");\n    }\n    if (this.activePrompt != null) {\n      this.activePrompt.reject(reason);\n      this.activePrompt = null;\n    }\n    if (this.activeCharPrompt != null) {\n      this.activeCharPrompt.reject(reason);\n      this.activeCharPrompt = null;\n    }\n    this.active = false;\n  }\n\n  /**\n   * Prints a message and changes line\n   */\n  async println(message: string) {\n    return this.print(message + \"\\n\");\n  }\n\n  /**\n   * Prints a message and properly handles new-lines\n   */\n  async print(message: string) {\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\n    this.writingPromise = this.internalWrite(normInput.replace(/\\n/g, \"\\r\\n\"));\n    return this.writingPromise;\n  }\n\n  /**\n   * Prints a list of items using a wide-format\n   */\n  printWide(items: string[], padding = 2) {\n    if (items.length == 0) return this.println(\"\");\n\n    // Compute item sizes and matrix row/cols\n    const itemWidth =\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\n    const wideCols = Math.floor(this.terminalSize.cols / itemWidth);\n    const wideRows = Math.ceil(items.length / wideCols);\n\n    // Print matrix\n    let i = 0;\n    for (let row = 0; row < wideRows; ++row) {\n      let rowStr = \"\";\n\n      // Prepare columns\n      for (let col = 0; col < wideCols; ++col) {\n        if (i < items.length) {\n          let item = items[i++];\n          item += \" \".repeat(itemWidth - item.length);\n          rowStr += item;\n        }\n      }\n      this.println(rowStr);\n    }\n  }\n\n  private attach() {\n    if (!this.terminal) return;\n    this.disposables.push(\n      this.terminal.onData((data) => this.handleTermData(data))\n    );\n    this.disposables.push(\n      this.terminal.onResize((size) => this.handleTermResize(size))\n    );\n\n    this.terminalSize = {\n      cols: this.terminal.cols,\n      rows: this.terminal.rows,\n    };\n  }\n\n  private detach() {\n    this.disposables.forEach((d) => d.dispose());\n    this.disposables = [];\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Internal API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /** Calls terminal.write, but promisify */\n  private async internalWrite(data: string | Uint8Array) {\n    return new Promise<void>((resolve) => {\n      this.terminal.write(data, resolve);\n    });\n  }\n\n  /**\n   * Apply prompts to the given input\n   */\n  private applyPrompts(input: string) {\n    const prompt = (this.activePrompt || {}).prompt || \"\";\n    const continuationPrompt =\n      (this.activePrompt || {}).continuationPrompt || \"\";\n\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n  }\n\n  /**\n   * Advances the `offset` as required in order to accompany the prompt\n   * additions to the input.\n   */\n  private applyPromptOffset(input: string, offset: number) {\n    const newInput = this.applyPrompts(input.substring(0, offset));\n    return newInput.replace(ansiRegex(), \"\").length;\n  }\n\n  /** Combine tab->space and CJK->space conversion. This make cursor calculation correct. */ \n  private toSingleWidth = (str: string) => parseUnicode(replaceTabToSpace(str), this.terminal.cols);\n\n  /**\n   * Clears the current prompt\n   *\n   * This function will erase all the lines that display the current prompt\n   * and move the cursor in the beginning of the first line of the prompt.\n   */\n  private clearInput() {\n    const currentPrompt = this.applyPrompts(this.input);\n\n    // Get the overall number of lines to clear\n    const allRows = countLines(currentPrompt, this.terminalSize.cols);\n\n    // Get the line we are currently in\n    const promptCursor = this.applyPromptOffset(this.input, this.cursor);\n    const { col, row } = offsetToColRow(\n      currentPrompt,\n      promptCursor,\n      this.terminalSize.cols\n    );\n\n    // First move on the last line\n    const moveRows = allRows - row - 1;\n\n    // console.log('clear: ', { col, row, moveRows });\n\n    // negative, move up\n    for (let i = moveRows; i < 0; ++i) this.terminal.write(\"\\x1B[2K\\x1B[F\");\n    // positive, move down\n    for (let i = 0; i < moveRows; ++i) this.terminal.write(\"\\x1B[E\");\n\n    // Clear current input line(s)\n    this.terminal.write(\"\\r\\x1B[K\");\n    for (let i = 1; i < allRows; ++i) this.terminal.write(\"\\x1B[F\\x1B[K\");\n  }\n\n  /**\n   * Replace input with the new input given\n   *\n   * This function clears all the lines that the current input occupies and\n   * then replaces them with the new input.\n   */\n  private setInput(newInput: string, clearInput = true) {\n    // Clear current input\n    if (clearInput) this.clearInput();\n\n    // Write the new input lines, including the current prompt\n    // Need to replace tab here, for new-line compatibility\n    const newPrompt = this.applyPrompts(newInput);\n    this.print(newPrompt);\n\n    // Trim cursor overflow\n    if (this.cursor > newInput.length) {\n      this.cursor = newInput.length;\n    }\n\n    // Move the cursor to the appropriate row/col\n    const newCursor = this.applyPromptOffset(newInput, this.cursor);\n    const newLines = countLines(newPrompt, this.terminalSize.cols);\n    const { col, row } = offsetToColRow(\n      newPrompt,\n      newCursor,\n      this.terminalSize.cols\n    );\n    const moveUpRows = newLines - row - 1;\n\n    // console.log({ col, row, moveUpRows });\n\n    // xterm keep the cursor on last column when it is at the end of the line.\n    // Move it to next line.\n    if (row !== 0 && col === 0) this.terminal.write(\"\\x1B[E\");\n\n    this.terminal.write(\"\\r\");\n    for (let i = 0; i < moveUpRows; ++i) this.terminal.write(\"\\x1B[F\");\n    for (let i = 0; i < col; ++i) this.terminal.write(\"\\x1B[C\");\n\n    // Replace input\n    this.input = newInput;\n  }\n\n  /**\n   * This function completes the current input, calls the given callback\n   * and then re-displays the prompt.\n   */\n  private printAndRestartPrompt(callback: any) {\n    const cursor = this.cursor;\n\n    // Complete input\n    this.setCursor(this.input.length);\n    this.terminal.write(\"\\r\\n\");\n\n    // Prepare a function that will resume prompt\n    const resume = () => {\n      this.cursor = cursor;\n      this.setInput(this.input);\n    };\n\n    // Call the given callback to echo something, and if there is a promise\n    // returned, wait for the resolution before resuming prompt.\n    const ret = callback();\n    if (ret == null) {\n      resume();\n    } else {\n      ret.then(resume);\n    }\n  }\n\n  /**\n   * Set the new cursor position, as an offset on the input string\n   *\n   * This function:\n   * - Calculates the previous and current\n   */\n  private setCursor(newCursor: number) {\n    if (newCursor < 0) newCursor = 0;\n    if (newCursor > this.input.length) newCursor = this.input.length;\n\n    // Apply prompt formatting to get the visual status of the display\n    const inputWithPrompt = this.applyPrompts(this.input);\n\n    // Estimate previous cursor position\n    const prevPromptOffset = this.applyPromptOffset(this.input, this.cursor);\n    const { col: prevCol, row: prevRow } = offsetToColRow(\n      inputWithPrompt,\n      prevPromptOffset,\n      this.terminalSize.cols\n    );\n\n    // Estimate next cursor position\n    const newPromptOffset = this.applyPromptOffset(this.input, newCursor);\n    const { col: newCol, row: newRow } = offsetToColRow(\n      inputWithPrompt,\n      newPromptOffset,\n      this.terminalSize.cols\n    );\n\n    // Adjust vertically\n    if (newRow > prevRow) {\n      for (let i = prevRow; i < newRow; ++i) this.terminal.write(\"\\x1B[B\");\n    } else {\n      for (let i = newRow; i < prevRow; ++i) this.terminal.write(\"\\x1B[A\");\n    }\n\n    // Adjust horizontally\n    if (newCol > prevCol) {\n      for (let i = prevCol; i < newCol; ++i) this.terminal.write(\"\\x1B[C\");\n    } else {\n      for (let i = newCol; i < prevCol; ++i) this.terminal.write(\"\\x1B[D\");\n    }\n\n    // Set new offset\n    this.cursor = newCursor;\n  }\n\n  /**\n   * Move cursor at given direction\n   */\n  private handleCursorMove(dir: number) {\n    if (dir > 0) {\n      const num = Math.min(dir, this.input.length - this.cursor);\n      this.setCursor(this.cursor + num);\n    } else if (dir < 0) {\n      const num = Math.max(dir, -this.cursor);\n      this.setCursor(this.cursor + num);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   */\n  private handleCursorErase(backspace: boolean) {\n    if (backspace) {\n      if (this.cursor <= 0) return;\n      const newInput =\n        this.input.substring(0, this.cursor - 1) + this.input.substring(this.cursor);\n      this.clearInput();\n      this.cursor -= 1;\n      this.setInput(newInput, false);\n    } else {\n      const newInput =\n        this.input.substring(0, this.cursor) + this.input.substring(this.cursor + 1);\n      this.setInput(newInput);\n    }\n  }\n\n  /**\n   * Insert character at cursor location\n   */\n  private handleCursorInsert(data: string) {\n    const newInput =\n      this.input.substring(0, this.cursor) + data + this.input.substring(this.cursor);\n    this.cursor += data.length;\n    this.setInput(newInput);\n  }\n\n  /**\n   * Handle input completion\n   */\n  private async handleReadComplete() {\n    if (this.history) {\n      this.history.push(this.input);\n    }\n    await this.internalWrite(\"\\r\\n\");\n    if (this.activePrompt) {\n      this.activePrompt.resolve(this.input);\n      this.activePrompt = null;\n    }\n    this.active = false;\n  }\n\n  /**\n   * Handle terminal resize\n   *\n   * This function clears the prompt using the previous configuration,\n   * updates the cached terminal size information and then re-renders the\n   * input. This leads (most of the times) into a better formatted input.\n   */\n  private handleTermResize(data: Size) {\n    const { rows, cols } = data;\n    this.clearInput();\n    this.terminalSize = { cols, rows };\n    this.setInput(this.input, false);\n  }\n\n  /**\n   * Handle terminal input\n   */\n  private handleTermData(data: string) {\n    if (!this.active) return;\n    if (data.length === 0) return;\n\n    // If we have an active character prompt, satisfy it in priority\n    if (this.activeCharPrompt != null) {\n      this.activeCharPrompt.resolve(data);\n      this.activeCharPrompt = null;\n      this.terminal.write(\"\\r\\n\");\n      return;\n    }\n\n    // Looks like a pasted input.\n    // Handle a line, then put another to this.remainKeys.\n    // When next read call comes, we'll handle them.\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n      for (let i = 0; i < data.length; i++) {\n        this.handleData(data[i]);\n        if (data[i] === '\\r') {\n          this.remainKeys = data.substring(i + 1);\n          break;\n        }\n      }\n    } else {\n      this.handleData(data);\n      this.remainKeys = \"\";\n    }\n  }\n\n  /**\n   * Handle a single piece of information from the terminal.\n   */\n  private handleData(data: string) {\n    if (!this.active) return;\n    const ord = data.charCodeAt(0);\n    let ofs;\n\n    // Handle ANSI escape sequences\n    if (ord == 0x1b) {\n      switch (data.substring(1)) {\n        case \"[A\": // Up arrow\n          if (this.history) {\n            const value = this.history.getPrevious();\n            if (value) {\n              this.setInput(value);\n              this.setCursor(value.length);\n            }\n          }\n          break;\n\n        case \"[B\": // Down arrow\n          if (this.history) {\n            let value = this.history.getNext();\n            if (!value) value = \"\";\n            this.setInput(value);\n            this.setCursor(value.length);\n          }\n          break;\n\n        case \"[D\": // Left Arrow\n          this.handleCursorMove(-1);\n          break;\n\n        case \"[C\": // Right Arrow\n          this.handleCursorMove(1);\n          break;\n\n        case \"[3~\": // Delete\n          this.handleCursorErase(false);\n          break;\n\n        case \"[F\": // End\n          this.setCursor(this.input.length);\n          break;\n\n        case \"[H\": // Home\n          this.setCursor(0);\n          break;\n\n        case \"b\": // ALT + LEFT\n          ofs = closestLeftBoundary(this.input, this.cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"f\": // ALT + RIGHT\n          ofs = closestRightBoundary(this.input, this.cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"\\x7F\": // CTRL + BACKSPACE\n          ofs = closestLeftBoundary(this.input, this.cursor);\n          if (ofs != null) {\n            this.setInput(\n              this.input.substring(0, ofs) + this.input.substring(this.cursor)\n            );\n            this.setCursor(ofs);\n          }\n          break;\n      }\n\n      // Handle special characters\n    } else if (ord < 32 || ord === 0x7f) {\n      switch (data) {\n        case \"\\r\": // ENTER\n          if (this.enableIncompleteInput && isIncompleteInput(this.input)) {\n            this.handleCursorInsert(\"\\n\");\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        case \"\\x7F\": // BACKSPACE\n          this.handleCursorErase(true);\n          break;\n\n        case \"\\t\": // TAB\n          if (this.enableAutocomplete) {\n            if (this.autocompleteHandlers.length > 0) {\n              const inputFragment = this.input.substring(0, this.cursor);\n              const hasTailingSpace = hasTailingWhitespace(inputFragment);\n              const candidates = collectAutocompleteCandidates(\n                this.autocompleteHandlers,\n                inputFragment\n              );\n\n              // Sort candidates\n              candidates.sort();\n\n              // Depending on the number of candidates, we are handing them in\n              // a different way.\n              if (candidates.length === 0) {\n                // No candidates? Just add a space if there is none already\n                if (!hasTailingSpace) {\n                  this.handleCursorInsert(\" \");\n                }\n              } else if (candidates.length === 1) {\n                // Just a single candidate? Complete\n                const lastToken = getLastToken(inputFragment);\n                this.handleCursorInsert(\n                  candidates[0].substring(lastToken.length) + \" \"\n                );\n              } else if (candidates.length <= this.maxAutocompleteEntries) {\n                // search for a shared fragement\n                const sameFragment = getSharedFragment(inputFragment, candidates);\n\n                // if there's a shared fragement between the candidates\n                // print complete the shared fragment\n                if (sameFragment) {\n                  const lastToken = getLastToken(inputFragment);\n                  this.handleCursorInsert(sameFragment.substring(lastToken.length));\n                }\n\n                // If we are less than maximum auto-complete candidates, print\n                // them to the user and re-start prompt\n                this.printAndRestartPrompt(() => {\n                  this.printWide(candidates);\n                });\n              } else {\n                // If we have more than maximum auto-complete candidates, print\n                // them only if the user acknowledges a warning\n                this.printAndRestartPrompt(() =>\n                  this.readChar(\n                    `Display all ${candidates.length} possibilities? (y or n)`\n                  ).then((yn) => {\n                    if (yn == \"y\" || yn == \"Y\") {\n                      this.printWide(candidates);\n                    }\n                  })\n                );\n              }\n            }\n          } else {\n            this.handleCursorInsert(\"\\t\");\n          }\n          break;\n\n        case \"\\x03\": // CTRL+C\n          this.setCursor(this.input.length);\n          this.terminal.write(\n            \"^C\\r\\n\" + ((this.activePrompt || {}).prompt || \"\")\n          );\n          this.input = \"\";\n          this.cursor = 0;\n          if (this.history) this.history.rewind();\n          this.emitInterrupt();\n          break;\n\n        case \"\\x04\": // CTRL+D\n          this.setCursor(this.input.length);\n          this.terminal.write(\n            \"^D\\r\\n\" + ((this.activePrompt || {}).prompt || \"\")\n          );\n          this.input = \"\";\n          this.cursor = 0;\n          if (this.history) this.history.rewind();\n          this.abortRead();\n          this.emitEof();\n          break;\n      }\n\n      // Handle visible characters\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n}\n"],"names":["ansiRegex","onlyFirst","pattern","join","RegExp","undefined","HistoryController","constructor","size","entries","cursor","this","push","entry","trim","length","shift","rewind","getPrevious","idx","Math","max","getNext","min","CONTROL","TOKEN","i","pow","random","toString","s","env","opts","mapped","chunker","match","filter","Boolean","commented","map","j","test","op","BS","escape","quote","esc","out","isGlob","len","c","charAt","parseEnvVar","comment","slice","varend","varname","key","r","Error","substr","indexOf","index","JSON","stringify","reduce","prev","arg","concat","parse","acc","xs","split","x","BMP_COMBINING","HIGH_COMBINING","table","Uint8Array","fill","wordBoundaries","input","leftSide","words","rx","exec","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","row","col","countLines","replace","hasTailingWhitespace","getLastToken","pop","getSharedFragment","fragment","candidates","oldFragment","startsWith","IoEventTarget","EventTarget","emitEof","dispatchEvent","Event","emitInterrupt","onEof","callback","addEventListener","onInterrupt","LocalEchoAddon","option","super","history","terminal","disposables","enableAutocomplete","maxAutocompleteEntries","enableIncompleteInput","autocompleteHandlers","active","activePrompt","activeCharPrompt","writingPromise","remainKeys","terminalSize","cols","rows","toSingleWidth","str","output","width","num","charCodeAt","ucs","data","mid","bisearch","parseUnicode","spaces","repeat","replaceTabToSpace","historySize","activate","attach","dispose","detach","addAutocompleteHandler","fn","args","removeAutocompleteHandler","findIndex","e","splice","read","prompt","continuationPrompt","Promise","resolve","reject","select","buffer","cursorY","cursorX","getSelection","clearSelection","write","handleTermData","readChar","abortRead","reason","println","message","print","normInput","internalWrite","printWide","items","padding","itemWidth","item","wideCols","floor","wideRows","ceil","rowStr","onData","onResize","handleTermResize","forEach","d","applyPrompts","applyPromptOffset","substring","clearInput","currentPrompt","allRows","promptCursor","moveRows","setInput","newInput","newPrompt","newCursor","newLines","moveUpRows","printAndRestartPrompt","setCursor","resume","ret","then","inputWithPrompt","prevPromptOffset","prevCol","prevRow","newPromptOffset","newCol","newRow","handleCursorMove","dir","handleCursorErase","backspace","handleCursorInsert","handleReadComplete","handleData","ord","ofs","value","closestRightBoundary","endsWith","inputFragment","hasTailingSpace","callbacks","tokens","expr","console","error","txt","collectAutocompleteCandidates","sort","lastToken","sameFragment","yn"],"mappings":"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AQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAC7C,CAAC,KAAQ,M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"}